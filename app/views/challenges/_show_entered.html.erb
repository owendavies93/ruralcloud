<% started = has_started(@challenge)
   ended = has_ended(@challenge) %>
<div class="info">
  <% if !started %>
    <p>This challenge starts in:</p>
  <% elsif !ended %>
    <div id="start-countdown"></div>
  <% else %>
    <p>This challenge has ended!</P>
  <% end %>
</div>

<div class="container-fluid">
  <div class="row-fluid">
    <div class="span6">
      <textarea rows="30" id="editor" placeholder=""></textarea>
    <a id="compile-button" class="btn btn-primary" <% started && !ended ? "" : "disabled" %>>Compile</a>
    </div>
    <div class="span6">
      <div class="row-fluid codewrapper">
        <textarea <% started && !ended ? "" : "disabled" %> rows="15" id="console">$> </textarea>
      </div>
      <div class="row-fluid" id="spec">
        <blockquote style="max-height:500px; overflow:auto">
          <% if !started %>
            <h3>Challenge #<%= @challenge.id %></h3>
            <p>
              <b>Description:</b>
              <%= @challenge.description %>
            </p>

            <p>
              <b>Difficulty:</b>
              <%= @challenge.difficulty %>
            </p>

            <p>
              <b>Owner:</b>
              <%= @challenge.owner %>
            </p>

            <p>The specification for this challenge will appear here once the challenge has started.</p>
          <% else
            markdown = Redcarpet::Markdown.new(Redcarpet::Render::HTML, :autolink => true, :space_after_headers => true)
            htm = markdown.render(@challenge.spec) %>
            <%= htm.html_safe %>
          <% end %>
        </blockquote>
      </div>
    </div>
  </div>
</div>


<script type="text/javascript">

<% if !started %>

  var starttime = new Date(<%= DateTime.strptime(@challenge.starttime.to_s,"%m-%d-%Y %H:%M").to_i %> * 1000);
  $("#start-countdown").countdown({until: starttime});

<% elsif !ended %>

  var endtime = new Date(<%= DateTime.strptime(@challenge.endtime.to_s,"%m-%d-%Y %H:%M").to_i %> * 1000);
  $("#start-countdown").countdown({until: endtime});
<% end %>

  var editor = CodeMirror.fromTextArea(document.getElementById('editor'), {
      mode: "haskell",
      lineNumbers: true,
      tabSize: 2,
      readOnly: "<%= started && !ended ? "" : "nocursor" %>"
    });

  var used = new Array();
  var history = new Array();
  var currentline = 0;
  var prompt = "$> "

  var co = CodeMirror.fromTextArea(document.getElementById('console'), {
      mode: "shell",
      readOnly: "<%= started && !ended ? "" : "nocursor" %>",
      extraKeys: {
        Enter: function(co) {
          co.setCursor({line: co.getCursor().line});
          co.replaceSelection("\n", "end", "+input");

          var cmd = co.getLine(co.lineCount() - 2).substring(3);
          // Send cmd to server, get back result

          co.setLine(co.lineCount() - 1, "You typed " + cmd);
          co.replaceSelection("\n" + prompt, "end", "+input");
          // 'Mark' lines as uneditable
          used.push(co.lineCount() - 2);
          used.push(co.lineCount() - 3);

          // Add cmd to history
          history.push(cmd);
          currentline++;
          console.log(history);
        },

        // Intercept backspace and delete to stop old command deletion
        Backspace: function(co) {
          var cur = co.getCursor().line;
          if ($.inArray(cur, used) == -1 && getCurLineLen(co) > 3) {
            co.deleteH(-1, "char");
          }
        },
        Delete: function(co) {
          var cur = co.getCursor().line;
          if ($.inArray(cur, used) == -1 && getCurLineLen(co) > 3) {
            co.deleteH(1, "char");
          }
        },

        // Use up and down for command history
        Up: function(co) {
          var cur = co.getCursor().line;
          if (currentline > 0) {
            co.setLine(cur, prompt + history[--currentline]);
          }
        },
        Down: function(co) {
          var cur = co.getCursor().line;
          console.log(cur);
          console.log(currentline);
          if (currentline < history.length - 1) {
            co.setLine(cur, prompt + history[++currentline]);
          } else {
            co.setLine(cur, prompt);
          }
        }
      }
    });

  co.setSize(null, 300);

  $("#compile-button").click(function(){
    // Send to server, get back result
    co.setLine(co.lineCount()-1, "Compiled");
    co.replaceSelection("\n" + prompt, "end", "+input");
  });

  function getCurLineLen(cm) {
    return cm.getLine(cm.getCursor().line).length
  };

</script>
